<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
  <title>AR.js • Hiro (Debug + 640x480 Processing)</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.4.1/aframe.min.js"></script>
  <!-- AR.js for A-Frame -->
  <script src="https://cdn.jsdelivr.net/npm/ar.js@3.4.5/aframe/build/aframe-ar.js"></script>

  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; }
    /* Background live camera feed (for you to SEE video) */
    #bg-video {
      position:fixed; inset:0;
      width:100%; height:100%;
      object-fit:cover;   /* change to 'contain' if you prefer letterboxing */
      z-index:0; background:#000;
    }
    /* A-Frame canvas overlays the video and is transparent */
    canvas.a-canvas {
      position:fixed !important; inset:0 !important;
      width:100% !important; height:100% !important;
      background:transparent !important;
      z-index:1 !important;
      pointer-events:none;
    }
    /* AR.js debug panel sits on top */
    .arjs-debugUI { z-index: 3 !important; }
    /* HUD */
    #hud {
      position:fixed; top:8px; left:8px; z-index:4;
      background:rgba(0,0,0,.6); color:#0f0;
      font:12px/1.4 monospace; padding:6px 8px; border-radius:6px; max-width:88vw; white-space:pre-wrap;
      display:none;
    }
    #hud.error { color:#fff; background:rgba(160,0,0,.85); display:block; }
    #hud.warn  { color:#000; background:rgba(255,215,0,.9); display:block; }
    /* Start overlay */
    #overlay {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:#000; color:#fff; z-index:5; text-align:center; padding:24px; font:16px/1.5 system-ui, sans-serif;
    }
    #overlay button {
      margin-top:12px; padding:12px 16px; border:0; border-radius:10px; font-weight:700;
      background:#1e90ff; color:#fff;
    }
  </style>
</head>
<body>
  <!-- Visible camera feed -->
  <video id="bg-video" playsinline muted autoplay></video>

  <div id="hud">status: booting…</div>
  <div id="overlay">
    <div>
      <div>This needs your camera to show AR on the <b>HIRO</b> marker.</div>
      <button id="startBtn">Start AR</button>
      <div style="margin-top:10px; font-size:12px; opacity:.8">
        If you blocked camera before: Chrome → lock icon → Site settings → Camera → Allow, then tap Start again.
      </div>
    </div>
  </div>

  <div id="app"></div>

  <script>
    const hud = document.getElementById('hud');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');
    const bgVideo = document.getElementById('bg-video');
    const log = (t, cls='') => { hud.textContent = 'status: ' + t; hud.className = cls; hud.style.display='block'; console.log('[AR]', t); };

    let savedStream = null;

    async function getStream() {
      try {
        return await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });
      } catch (e1) {
        console.warn('Back camera constraints failed; retrying loose video constraint', e1);
        return await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      }
    }

    function patchGetUserMedia(stream) {
      const orig = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
      navigator.mediaDevices.getUserMedia = function(constraints) {
        console.log('[AR] Patched gUM returning saved stream. Requested:', constraints);
        return Promise.resolve(stream);
      };
    }

    function injectScene() {
      // IMPORTANT: Give AR.js a 640x480 processing size (keeps detection stable on many Android devices)
      document.getElementById('app').innerHTML = `
        <a-scene
          id="scene"
          embedded
          vr-mode-ui="enabled: false"
          renderer="alpha: true; antialias: true; logarithmicDepthBuffer: true"
          arjs="
            sourceType: webcam;
            detectionMode: mono;
            trackingMethod: best;
            debugUIEnabled: true;
            sourceWidth: 640; sourceHeight: 480;
            displayWidth: 1280; displayHeight: 720;
          "
        >
          <!-- Lights so the overlay is always visible -->
          <a-entity light="type: ambient; intensity: 1.0"></a-entity>
          <a-entity light="type: directional; intensity: 0.9" position="0 1 1"></a-entity>

          <!-- HIRO marker with big geometry -->
          <a-marker preset="hiro" emitevents="true">
            <a-plane position="0 0 0" rotation="-90 0 0" width="1.3" height="1.3" color="#ffffff"></a-plane>
            <a-cylinder position="0 0.35 0" radius="0.1" height="0.7" color="#39f"></a-cylinder>
            <a-cone position="0 0.8 0" radius-bottom="0.22" height="0.28" color="#f93"></a-cone>
            <a-entity position="0 1.05 0" text="value: HIRO FOUND; align: center; width: 3; color: #00ff88"></a-entity>
          </a-marker>

          <a-entity camera="fov: 80"></a-entity>
        </a-scene>
      `;

      // Ensure AR.js internal video exists, is playing, and has non-zero size
      const ensureArVideoReady = () => {
        const v = document.getElementById('arjs-video');
        if (!v) return requestAnimationFrame(ensureArVideoReady);
        if (!v.srcObject && savedStream) v.srcObject = savedStream;
        v.setAttribute('playsinline',''); v.setAttribute('webkit-playsinline','');
        v.muted = true; v.autoplay = true;
        v.addEventListener('loadedmetadata', () => {
          log(`AR.js video ready: ${v.videoWidth}×${v.videoHeight}`);
          if (!v.videoWidth || !v.videoHeight) log('Warning: AR.js video has 0 size — reload or restart Chrome', 'warn');
        });
        v.play().catch(()=>{});
      };
      ensureArVideoReady();

      const scene = document.getElementById('scene');
      scene.addEventListener('arReady', () => log('arReady (AR.js initialized)'));
      scene.addEventListener('arError', (e) => log('arError: ' + (e && e.detail ? e.detail : 'unknown'), 'error'));

      const marker = document.querySelector('a-marker');
      if (marker){
        marker.addEventListener('markerFound', () => log('markerFound'));
        marker.addEventListener('markerLost',  () => log('markerLost', 'warn'));
      }
    }

    async function startAR() {
      log('requesting camera…');
      try {
        savedStream = await getStream();
      } catch (e) {
        const name = e && e.name ? e.name : '';
        let hint = '';
        if (name === 'NotAllowedError' || name === 'SecurityError') hint = '\nEnable camera: Chrome → lock icon → Site settings → Camera → Allow.';
        if (name === 'NotReadableError') hint = '\nCamera busy. Close other camera apps/tabs, force-close Chrome, or reboot.';
        log(`camera error: ${name || e}${hint}`, 'error');
        return;
      }

      // Show background video (proves frames are flowing)
      bgVideo.srcObject = savedStream;
      bgVideo.setAttribute('playsinline',''); bgVideo.setAttribute('webkit-playsinline',''); bgVideo.muted = true;
      bgVideo.play().catch(()=>{});
      log('camera streaming (background visible)');

      // Force AR.js to use the same stream, then create the scene
      patchGetUserMedia(savedStream);
      overlay.style.display = 'none';
      injectScene();

      // If AR.js recreates video element later, reattach our stream
      const obs = new MutationObserver(() => {
        const v = document.getElementById('arjs-video');
        if (v && !v.srcObject && savedStream) { v.srcObject = savedStream; v.play().catch(()=>{}); log('re-attached stream to AR.js'); }
      });
      obs.observe(document.body, { childList: true, subtree: true });
    }

    startBtn.addEventListener('click', startAR);

    // Auto-start if permission already granted
    (async () => {
      try {
        const t = await navigator.mediaDevices.getUserMedia({ video: true, audio: false
